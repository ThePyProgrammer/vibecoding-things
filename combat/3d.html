<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>COMBAT 3D</title>
<style>
  * { margin:0; padding:0; box-sizing:border-box; }
  body { background:#000; overflow:hidden; font-family:'Share Tech Mono',monospace; }
  #c { display:block; width:100vw; height:100vh; }

  #hud {
    position:fixed; top:0; left:0; right:0;
    display:flex; justify-content:space-between; align-items:flex-start;
    padding:18px 28px; pointer-events:none;
    background: linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, transparent 100%);
  }

  .hud-block { display:flex; flex-direction:column; gap:6px; }

  .hud-label {
    font-size:0.62rem; letter-spacing:0.3em; color:#666;
  }

  .hud-val {
    font-size:1.6rem; font-weight:700; letter-spacing:0.05em;
  }

  .hud-val.player { color:#4de1ff; text-shadow: 0 0 12px #4de1ffaa; }
  .hud-val.enemy  { color:#ff5533; text-shadow: 0 0 12px #ff553388; }

  .health-bar {
    width:140px; height:6px; background:#222; border-radius:3px; overflow:hidden;
  }
  .health-fill {
    height:100%; border-radius:3px; transition: width 0.3s;
  }
  .health-fill.player { background: linear-gradient(90deg,#4de1ff,#4de1ff88); }
  .health-fill.enemy  { background: linear-gradient(90deg,#ff5533,#ff553388); }

  .hud-center {
    text-align:center;
  }
  .score-display {
    font-size:2.2rem; letter-spacing:0.2em; color:#f5e642;
    text-shadow:0 0 20px #f5e64288;
  }
  .score-sep { color:#444; }
  .hud-title {
    font-size:0.6rem; letter-spacing:0.4em; color:#555; margin-bottom:4px;
  }

  #crosshair {
    position:fixed; top:50%; left:50%;
    transform:translate(-50%,-50%);
    pointer-events:none;
    width:28px; height:28px;
  }
  #crosshair::before, #crosshair::after {
    content:''; position:absolute; background:#ffffff88;
  }
  #crosshair::before { width:2px; height:28px; left:13px; top:0; }
  #crosshair::after  { width:28px; height:2px; top:13px; left:0; }
  .ch-dot {
    position:absolute; width:4px; height:4px;
    background:#4de1ff; border-radius:50%;
    top:12px; left:12px;
    box-shadow: 0 0 6px #4de1ff;
  }

  #controls-hint {
    position:fixed; bottom:20px; left:50%; transform:translateX(-50%);
    font-size:0.62rem; letter-spacing:0.25em; color:#444;
    pointer-events:none;
  }

  #overlay {
    position:fixed; inset:0;
    background:#000;
    display:flex; flex-direction:column;
    align-items:center; justify-content:center;
    z-index:100;
    transition: opacity 0.6s;
  }
  #overlay.hidden { opacity:0; pointer-events:none; }

  .overlay-title {
    font-size:4rem; letter-spacing:0.3em; color:#f5e642;
    text-shadow: 0 0 40px #f5e642aa;
    margin-bottom:8px;
  }
  .overlay-sub {
    font-size:0.75rem; letter-spacing:0.4em; color:#555;
    margin-bottom:50px;
  }
  .overlay-keys {
    display:grid; grid-template-columns:1fr 1fr; gap:10px 40px;
    font-size:0.78rem; color:#888; margin-bottom:50px;
  }
  .overlay-keys span { color:#ccc; }
  .start-btn {
    background:none; border:2px solid #f5e642; color:#f5e642;
    font-family:'Share Tech Mono',monospace; font-size:1rem;
    letter-spacing:0.3em; padding:14px 44px; cursor:pointer;
    text-shadow:0 0 10px #f5e64288;
    transition: background 0.2s, box-shadow 0.2s;
  }
  .start-btn:hover {
    background:#f5e64222;
    box-shadow: 0 0 30px #f5e64244;
  }

  #win-overlay {
    position:fixed; inset:0;
    background:rgba(0,0,0,0.88);
    display:none;
    flex-direction:column; align-items:center; justify-content:center;
    z-index:200;
  }
  #win-overlay.show { display:flex; }
  #win-text { font-size:3rem; letter-spacing:0.15em; margin-bottom:10px; }
  #win-sub  { font-size:0.72rem; letter-spacing:0.35em; color:#666; margin-bottom:40px; }
  .again-btn {
    background:none; border:2px solid #f5e642; color:#f5e642;
    font-family:'Share Tech Mono',monospace; font-size:0.9rem;
    letter-spacing:0.25em; padding:12px 36px; cursor:pointer;
  }
  .again-btn:hover { background:#f5e64222; }

  #minimap {
    position:fixed; bottom:20px; right:20px;
    width:130px; height:130px;
    background:rgba(0,0,0,0.7);
    border:1px solid #333;
    border-radius:4px;
    overflow:hidden;
  }
  #minimap canvas { display:block; }

  #reload-bar {
    position:fixed; bottom:60px; left:50%; transform:translateX(-50%);
    width:120px; height:4px; background:#222; border-radius:2px; overflow:hidden;
  }
  #reload-fill {
    height:100%; background:#4de1ff; width:100%;
    transition: width 0.05s linear;
    box-shadow: 0 0 6px #4de1ff;
  }
</style>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
</head>
<body>

<canvas id="c"></canvas>

<div id="hud">
  <div class="hud-block">
    <div class="hud-label">PLAYER</div>
    <div class="hud-val player" id="p-score">0</div>
    <div class="health-bar"><div class="health-fill player" id="p-health" style="width:100%"></div></div>
  </div>
  <div class="hud-block hud-center">
    <div class="hud-title" style="font-family:'Orbitron',sans-serif;">COMBAT 3D</div>
    <div class="score-display"><span id="sc1">0</span><span class="score-sep"> — </span><span id="sc2">0</span></div>
  </div>
  <div class="hud-block" style="align-items:flex-end">
    <div class="hud-label">ENEMY AI</div>
    <div class="hud-val enemy" id="e-score">0</div>
    <div class="health-bar"><div class="health-fill enemy" id="e-health" style="width:100%"></div></div>
  </div>
</div>

<div id="crosshair"><div class="ch-dot"></div></div>
<div id="controls-hint">WASD · MOVE &nbsp;|&nbsp; MOUSE · AIM &nbsp;|&nbsp; CLICK / SPACE · FIRE</div>
<div id="reload-bar"><div id="reload-fill"></div></div>

<div id="minimap"><canvas id="mm" width="130" height="130"></canvas></div>

<div id="overlay">
  <div class="overlay-title" style="font-family:'Orbitron',sans-serif;">COMBAT 3D</div>
  <div class="overlay-sub">SINGLE PLAYER vs AI · FIRST TO 10</div>
  <div class="overlay-keys">
    <div>MOVE</div><div><span>W A S D</span></div>
    <div>AIM</div><div><span>MOUSE</span></div>
    <div>FIRE</div><div><span>CLICK / SPACE</span></div>
    <div>SCORE</div><div><span>FIRST TO 10 WINS</span></div>
  </div>
  <button class="start-btn" id="startBtn">CLICK TO START</button>
</div>

<div id="win-overlay" id="winOverlay">
  <div id="win-text"></div>
  <div id="win-sub">FIRST TO 10 HITS</div>
  <button class="again-btn" onclick="resetGame()">PLAY AGAIN</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ─── SCENE SETUP ────────────────────────────────────────────────────────────
const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('c'), antialias:true });
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.setClearColor(0x0a0a0f);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 0.8;

window.addEventListener('resize', ()=>{
  renderer.setSize(innerWidth,innerHeight);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
});

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0a0a1a, 0.025);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 200);

// ─── LIGHTS ─────────────────────────────────────────────────────────────────
const ambient = new THREE.AmbientLight(0x112233, 0.6);
scene.add(ambient);

const sun = new THREE.DirectionalLight(0x88aaff, 0.8);
sun.position.set(10,20,10);
sun.castShadow = true;
sun.shadow.mapSize.width = 2048;
sun.shadow.mapSize.height = 2048;
sun.shadow.camera.near = 0.1;
sun.shadow.camera.far = 100;
sun.shadow.camera.left = -40;
sun.shadow.camera.right = 40;
sun.shadow.camera.top = 40;
sun.shadow.camera.bottom = -40;
scene.add(sun);

// Rim light for drama
const rimLight = new THREE.DirectionalLight(0xff4422, 0.3);
rimLight.position.set(-10,5,-10);
scene.add(rimLight);

// ─── ARENA ──────────────────────────────────────────────────────────────────
const ARENA = 40; // half-size

// Floor
const floorGeo = new THREE.PlaneGeometry(ARENA*2, ARENA*2, 40, 40);
const floorMat = new THREE.MeshStandardMaterial({
  color:0x111122,
  roughness:0.9,
  metalness:0.1,
});
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI/2;
floor.receiveShadow = true;
scene.add(floor);

// Grid lines overlay
const gridHelper = new THREE.GridHelper(ARENA*2, 40, 0x223344, 0x1a2233);
scene.add(gridHelper);

// Walls & obstacles
const wallMat = new THREE.MeshStandardMaterial({ color:0x223344, roughness:0.7, metalness:0.3 });
const obstacles = [];

function makeBox(x, z, w, d, h=4) {
  const geo = new THREE.BoxGeometry(w, h, d);
  const mesh = new THREE.Mesh(geo, wallMat);
  mesh.position.set(x, h/2, z);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  scene.add(mesh);
  obstacles.push({ x, z, w, d, mesh });
  return mesh;
}

// Border walls (taller)
makeBox(0, -ARENA, ARENA*2, 2, 6);
makeBox(0,  ARENA, ARENA*2, 2, 6);
makeBox(-ARENA, 0, 2, ARENA*2, 6);
makeBox( ARENA, 0, 2, ARENA*2, 6);

// Interior obstacles
makeBox(-15, -10, 3, 12, 4);
makeBox( 15,  10, 3, 12, 4);
makeBox(  0,   0, 8,  3, 4);
makeBox(-20,  18, 3,  8, 4);
makeBox( 20, -18, 3,  8, 4);
makeBox(-10,  25, 10, 3, 4);
makeBox( 10, -25, 10, 3, 4);
makeBox(-28,  -5, 5,  3, 4);
makeBox( 28,   5, 5,  3, 4);
makeBox(  5,  15, 3,  3, 5);
makeBox( -5, -15, 3,  3, 5);

// Glowing accent strips on walls
function addWallGlow(x,z,rx,ry,rz,color) {
  const geo = new THREE.PlaneGeometry(6,0.15);
  const mat = new THREE.MeshBasicMaterial({color});
  const m = new THREE.Mesh(geo,mat);
  m.position.set(x,2.5,z);
  m.rotation.set(rx,ry,rz);
  scene.add(m);
}
addWallGlow(-15,-10+6,0,Math.PI/2,0,0x4de1ff);
addWallGlow(15,10-6,0,Math.PI/2,0,0xff5533);

// ─── TANK FACTORY ────────────────────────────────────────────────────────────
function makeTank(color, glowColor) {
  const group = new THREE.Group();

  const bodyMat = new THREE.MeshStandardMaterial({
    color, roughness:0.4, metalness:0.6,
    emissive: glowColor, emissiveIntensity: 0.1
  });
  const darkMat = new THREE.MeshStandardMaterial({ color:0x111111, roughness:0.9 });

  // Hull
  const hull = new THREE.Mesh(new THREE.BoxGeometry(2.4,0.8,3.2), bodyMat);
  hull.position.y = 0.55;
  hull.castShadow = true;
  group.add(hull);

  // Treads
  [-1.15,1.15].forEach(x => {
    const t = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.7,3.4), darkMat);
    t.position.set(x,0.45,0);
    t.castShadow=true;
    group.add(t);
    // Tread segments
    for (let i=-1.5; i<=1.5; i+=0.5) {
      const s = new THREE.Mesh(new THREE.BoxGeometry(0.55,0.12,0.08), bodyMat);
      s.position.set(x,0.82,i);
      group.add(s);
    }
  });

  // Turret base
  const turretBase = new THREE.Mesh(
    new THREE.CylinderGeometry(0.7,0.8,0.5,8), bodyMat
  );
  turretBase.position.y = 1.15;
  turretBase.castShadow=true;
  group.add(turretBase);

  // Barrel
  const barrel = new THREE.Mesh(
    new THREE.CylinderGeometry(0.12,0.15,2.0,8), bodyMat
  );
  barrel.rotation.x = Math.PI/2;
  barrel.position.set(0, 1.15, -1.4);
  barrel.castShadow=true;
  group.add(barrel);

  // Point light inside
  const glow = new THREE.PointLight(glowColor, 1.5, 6);
  glow.position.set(0,1,0);
  group.add(glow);

  group.castShadow = true;
  return group;
}

// ─── GAME STATE ──────────────────────────────────────────────────────────────
let playerTank, enemyTank;
let playerState, enemyState;
let bullets = [];
let particles = [];
let pScore = 0, eScore = 0;
let pHP = 100, eHP = 100;
let pReload = 0, eReload = 0;
let gameRunning = false;

const TANK_SPEED   = 8;
const TURN_SPEED   = 2.2;
const BULLET_SPEED = 28;
const RELOAD_TIME  = 0.7;
const BULLET_LIFE  = 3.0;
const HP_PER_HIT   = 25;

function buildScene() {
  if (playerTank) scene.remove(playerTank);
  if (enemyTank)  scene.remove(enemyTank);
  bullets.forEach(b => { scene.remove(b.mesh); });
  particles.forEach(p => { scene.remove(p.mesh); });
  bullets = []; particles = [];

  playerTank = makeTank(0x1a8aff, 0x4de1ff);
  playerTank.position.set(-25, 0, 0);
  playerTank.rotation.y = Math.PI/2;
  scene.add(playerTank);

  enemyTank = makeTank(0xcc3311, 0xff5533);
  enemyTank.position.set(25, 0, 0);
  enemyTank.rotation.y = -Math.PI/2;
  scene.add(enemyTank);

  playerState = {
    vel: new THREE.Vector3(),
    yaw: Math.PI/2,
    pitch: 0,
  };

  enemyState = {
    yaw: -Math.PI/2,
    vel: new THREE.Vector3(),
    reload: 0,
    thinkTimer: 0,
    targetYaw: -Math.PI/2,
    mode: 'patrol',
    patrolTarget: new THREE.Vector3(20, 0, 20),
    strafeDir: 1,
    strafeTimer: 0,
  };

  pReload = 0; eReload = 0;
  pHP = 100; eHP = 100;
  updateHUD();
}

// ─── BULLET CREATION ─────────────────────────────────────────────────────────
function spawnBullet(pos, dir, owner) {
  const geo = new THREE.SphereGeometry(0.18, 6, 6);
  const color = owner==='player' ? 0x4de1ff : 0xff5533;
  const mat = new THREE.MeshBasicMaterial({ color });
  const mesh = new THREE.Mesh(geo, mat);

  const spawnPos = pos.clone().add(dir.clone().multiplyScalar(2.2));
  spawnPos.y = Math.max(spawnPos.y, 0.5);
  mesh.position.copy(spawnPos);

  // Trail light
  const light = new THREE.PointLight(color, 2, 4);
  mesh.add(light);

  scene.add(mesh);
  bullets.push({ mesh, vel: dir.clone().multiplyScalar(BULLET_SPEED), owner, life: BULLET_LIFE });

  // Muzzle flash
  spawnExplosion(spawnPos, color, 0.4);
}

// ─── PARTICLES ───────────────────────────────────────────────────────────────
function spawnExplosion(pos, color, scale=1) {
  for (let i=0; i<12*scale; i++) {
    const geo = new THREE.SphereGeometry(0.08*scale, 4, 4);
    const mat = new THREE.MeshBasicMaterial({ color });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.copy(pos);
    scene.add(mesh);
    const vel = new THREE.Vector3(
      (Math.random()-0.5)*10*scale,
      Math.random()*8*scale,
      (Math.random()-0.5)*10*scale
    );
    particles.push({ mesh, vel, life: 0.5+Math.random()*0.4, maxLife: 0.9 });
  }
}

// ─── COLLISION ───────────────────────────────────────────────────────────────
function collideWithObstacles(pos, radius=1.5) {
  let pushed = new THREE.Vector3();
  for (const obs of obstacles) {
    const hw = obs.w/2 + radius;
    const hd = obs.d/2 + radius;
    const dx = pos.x - obs.x;
    const dz = pos.z - obs.z;
    if (Math.abs(dx) < hw && Math.abs(dz) < hd) {
      // Push out on shortest axis
      const ox = hw - Math.abs(dx);
      const oz = hd - Math.abs(dz);
      if (ox < oz) pushed.x += Math.sign(dx) * ox;
      else         pushed.z += Math.sign(dz) * oz;
    }
  }
  return pushed;
}

function clampArena(pos) {
  pos.x = Math.max(-ARENA+2, Math.min(ARENA-2, pos.x));
  pos.z = Math.max(-ARENA+2, Math.min(ARENA-2, pos.z));
}

// ─── INPUT ───────────────────────────────────────────────────────────────────
const keys = {};
document.addEventListener('keydown', e=>{ keys[e.code]=true; });
document.addEventListener('keyup',   e=>{ keys[e.code]=false; });

let mouseDX=0, mouseDY=0;
document.addEventListener('mousemove', e=>{
  if (!gameRunning) return;
  mouseDX += e.movementX;
  mouseDY += e.movementY;
});

document.addEventListener('mousedown', e=>{
  if (!gameRunning) return;
  if (pReload <= 0) {
    firePlayer();
  }
});

// ─── PLAYER FIRE ─────────────────────────────────────────────────────────────
function firePlayer() {
  const dir = new THREE.Vector3(0,0,-1)
    .applyEuler(new THREE.Euler(playerState.pitch, playerState.yaw, 0, 'YXZ'));
  spawnBullet(playerTank.position.clone(), dir, 'player');
  pReload = RELOAD_TIME;
}

// ─── AI LOGIC ────────────────────────────────────────────────────────────────
function updateAI(dt) {
  const es = enemyState;
  const ePos = enemyTank.position;
  const pPos = playerTank.position;

  const toPx = pPos.x - ePos.x;
  const toPz = pPos.z - ePos.z;
  const dist = Math.sqrt(toPx*toPx + toPz*toPz);
  const angleToPlayer = Math.atan2(-toPx, -toPz) + Math.PI;

  es.thinkTimer -= dt;

  // State machine
  if (dist < 8) {
    es.mode = 'strafe';
  } else if (dist > 25) {
    es.mode = 'chase';
  } else if (es.thinkTimer <= 0) {
    es.mode = Math.random() < 0.6 ? 'chase' : 'strafe';
    es.thinkTimer = 1.5 + Math.random()*2;
  }

  // --- Aim at player with some lead
  const aimAngle = Math.atan2(-(toPx), -(toPz)) + Math.PI;
  let da = aimAngle - es.yaw;
  while (da >  Math.PI) da -= Math.PI*2;
  while (da < -Math.PI) da += Math.PI*2;
  es.yaw += da * Math.min(1, 2.5*dt);

  // --- Move
  let fwd = 0, strafe = 0;
  if (es.mode === 'chase') {
    fwd = 1;
    // Steer toward player
    es.strafeTimer -= dt;
    if (es.strafeTimer <= 0) {
      es.strafeDir *= -1;
      es.strafeTimer = 1.2 + Math.random();
    }
    strafe = es.strafeDir * 0.3;
  } else if (es.mode === 'strafe') {
    // Circle the player
    es.strafeTimer -= dt;
    if (es.strafeTimer <= 0) {
      es.strafeDir *= -1;
      es.strafeTimer = 2+Math.random()*2;
    }
    strafe = es.strafeDir;
    fwd = 0.2;
  }

  const forward  = new THREE.Vector3(Math.sin(es.yaw), 0, Math.cos(es.yaw)).negate();
  const right    = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

  const move = forward.clone().multiplyScalar(fwd * TANK_SPEED * dt)
                .add(right.clone().multiplyScalar(strafe * TANK_SPEED * dt));

  ePos.add(move);
  const push = collideWithObstacles(ePos, 1.8);
  ePos.add(push);
  clampArena(ePos);
  ePos.y = 0;

  enemyTank.rotation.y = es.yaw + Math.PI;

  // --- Fire when roughly aimed at player
  const aimErr = Math.abs(da);
  es.reload -= dt;
  if (es.reload <= 0 && aimErr < 0.25 && dist < 35) {
    const fireDir = new THREE.Vector3(Math.sin(es.yaw), 0, Math.cos(es.yaw)).negate();
    // Add slight inaccuracy
    fireDir.x += (Math.random()-0.5)*0.12;
    fireDir.z += (Math.random()-0.5)*0.12;
    fireDir.normalize();
    spawnBullet(ePos.clone().add(new THREE.Vector3(0,1.15,0)), fireDir, 'enemy');
    const baseCD = 2.2;
    const scaledCD = baseCD * (eHP/100 * 0.5 + 0.5); // fires faster when damaged (aggression)
    es.reload = Math.max(0.8, scaledCD - dist*0.02);
  }
}

// ─── UPDATE BULLETS ──────────────────────────────────────────────────────────
function updateBullets(dt) {
  for (let i = bullets.length-1; i>=0; i--) {
    const b = bullets[i];
    b.life -= dt;
    if (b.life <= 0) { scene.remove(b.mesh); bullets.splice(i,1); continue; }

    const move = b.vel.clone().multiplyScalar(dt);
    b.mesh.position.add(move);

    // Wall bounce
    let bounced = false;
    for (const obs of obstacles) {
      const bx = b.mesh.position.x, bz = b.mesh.position.z;
      const hw = obs.w/2+0.3, hd = obs.d/2+0.3;
      if (Math.abs(bx-obs.x)<hw && Math.abs(bz-obs.z)<hd && b.mesh.position.y < 6) {
        // Reflect
        const ox = hw - Math.abs(bx-obs.x);
        const oz = hd - Math.abs(bz-obs.z);
        if (ox < oz) b.vel.x *= -1; else b.vel.z *= -1;
        bounced = true;
        b.life = Math.min(b.life, 0.8);
        spawnExplosion(b.mesh.position.clone(), b.owner==='player'?0x4de1ff:0xff5533, 0.3);
        break;
      }
    }

    // Arena walls
    const bp = b.mesh.position;
    if (Math.abs(bp.x) > ARENA-1) { b.vel.x *= -1; b.life=Math.min(b.life,0.8); }
    if (Math.abs(bp.z) > ARENA-1) { b.vel.z *= -1; b.life=Math.min(b.life,0.8); }

    // Floor/ceiling clamp
    if (bp.y < 0.2) { b.vel.y = Math.abs(b.vel.y)*0.4; bp.y = 0.2; }

    // Hit detection
    const hitPlayer = b.owner==='enemy'  && b.mesh.position.distanceTo(playerTank.position.clone().add(new THREE.Vector3(0,1,0))) < 1.8;
    const hitEnemy  = b.owner==='player' && b.mesh.position.distanceTo(enemyTank.position.clone().add(new THREE.Vector3(0,1,0)))  < 1.8;

    if (hitPlayer) {
      spawnExplosion(b.mesh.position.clone(), 0x4de1ff, 1.2);
      scene.remove(b.mesh); bullets.splice(i,1);
      pHP -= HP_PER_HIT;
      if (pHP <= 0) { eScore++; pHP=100; eHP=100; checkWin() || buildScene(); }
      updateHUD();
      continue;
    }
    if (hitEnemy) {
      spawnExplosion(b.mesh.position.clone(), 0xff5533, 1.2);
      scene.remove(b.mesh); bullets.splice(i,1);
      eHP -= HP_PER_HIT;
      if (eHP <= 0) { pScore++; pHP=100; eHP=100; checkWin() || buildScene(); }
      updateHUD();
      continue;
    }
  }
}

// ─── UPDATE PARTICLES ────────────────────────────────────────────────────────
function updateParticles(dt) {
  for (let i=particles.length-1; i>=0; i--) {
    const p = particles[i];
    p.life -= dt;
    if (p.life<=0) { scene.remove(p.mesh); particles.splice(i,1); continue; }
    p.vel.y -= 15*dt;
    p.mesh.position.addScaledVector(p.vel, dt);
    const t = p.life/p.maxLife;
    p.mesh.scale.setScalar(t*0.8+0.2);
  }
}

// ─── HUD / SCORE ─────────────────────────────────────────────────────────────
function updateHUD() {
  document.getElementById('p-health').style.width = Math.max(0,pHP)+'%';
  document.getElementById('e-health').style.width = Math.max(0,eHP)+'%';
  document.getElementById('sc1').textContent = pScore;
  document.getElementById('sc2').textContent = eScore;
}

function checkWin() {
  if (pScore >= 10 || eScore >= 10) {
    gameRunning = false;
    document.exitPointerLock && document.exitPointerLock();
    const ov = document.getElementById('win-overlay');
    const wt = document.getElementById('win-text');
    ov.classList.add('show');
    if (pScore >= 10) { wt.textContent = 'VICTORY'; wt.style.color='#4de1ff'; }
    else              { wt.textContent = 'DEFEATED'; wt.style.color='#ff5533'; }
    return true;
  }
  return false;
}

function resetGame() {
  document.getElementById('win-overlay').classList.remove('show');
  pScore=0; eScore=0;
  buildScene();
  gameRunning=true;
  updateHUD();
  document.getElementById('c').requestPointerLock();
}

// ─── MINIMAP ─────────────────────────────────────────────────────────────────
const mm = document.getElementById('mm');
const mctx = mm.getContext('2d');
const MM_SIZE = 130;
const MM_SCALE = MM_SIZE / (ARENA*2);

function drawMinimap() {
  mctx.fillStyle = '#0a0a14';
  mctx.fillRect(0,0,MM_SIZE,MM_SIZE);

  // walls
  mctx.fillStyle = '#2a3a4a';
  for (const obs of obstacles) {
    const ox = (obs.x + ARENA) * MM_SCALE - obs.w/2*MM_SCALE;
    const oz = (obs.z + ARENA) * MM_SCALE - obs.d/2*MM_SCALE;
    mctx.fillRect(ox, oz, obs.w*MM_SCALE, obs.d*MM_SCALE);
  }

  // bullets
  for (const b of bullets) {
    mctx.fillStyle = b.owner==='player' ? '#4de1ff' : '#ff5533';
    const bx = (b.mesh.position.x + ARENA) * MM_SCALE;
    const bz = (b.mesh.position.z + ARENA) * MM_SCALE;
    mctx.beginPath(); mctx.arc(bx,bz,1.5,0,Math.PI*2); mctx.fill();
  }

  // player
  const px = (playerTank.position.x+ARENA)*MM_SCALE;
  const pz = (playerTank.position.z+ARENA)*MM_SCALE;
  mctx.fillStyle='#4de1ff';
  mctx.shadowColor='#4de1ff'; mctx.shadowBlur=6;
  mctx.beginPath(); mctx.arc(px,pz,4,0,Math.PI*2); mctx.fill();
  mctx.shadowBlur=0;

  // enemy
  const ex = (enemyTank.position.x+ARENA)*MM_SCALE;
  const ez = (enemyTank.position.z+ARENA)*MM_SCALE;
  mctx.fillStyle='#ff5533';
  mctx.shadowColor='#ff5533'; mctx.shadowBlur=6;
  mctx.beginPath(); mctx.arc(ex,ez,4,0,Math.PI*2); mctx.fill();
  mctx.shadowBlur=0;
}

// ─── GAME LOOP ───────────────────────────────────────────────────────────────
let lastTime = performance.now();
let camPitch = 0, camYaw = Math.PI/2;

function loop() {
  requestAnimationFrame(loop);
  const now = performance.now();
  const dt = Math.min((now-lastTime)/1000, 0.05);
  lastTime = now;

  if (!gameRunning) { renderer.render(scene,camera); return; }

  // ─ Mouse look
  const sensitivity = 0.002;
  playerState.yaw   -= mouseDX * sensitivity;
  playerState.pitch  = Math.max(-0.4, Math.min(0.4, playerState.pitch - mouseDY*sensitivity));
  mouseDX = 0; mouseDY = 0;

  // ─ Player movement (tank-style: forward is barrel direction)
  const fwd = new THREE.Vector3(Math.sin(playerState.yaw), 0, Math.cos(playerState.yaw)).negate();
  const right = new THREE.Vector3().crossVectors(fwd, new THREE.Vector3(0,1,0)).normalize();

  let moveDir = new THREE.Vector3();
  if (keys['KeyW'] || keys['ArrowUp'])    moveDir.add(fwd);
  if (keys['KeyS'] || keys['ArrowDown'])  moveDir.sub(fwd);
  if (keys['KeyA'] || keys['ArrowLeft'])  moveDir.sub(right);
  if (keys['KeyD'] || keys['ArrowRight']) moveDir.add(right);
  if (moveDir.lengthSq() > 0) {
    moveDir.normalize();
    playerTank.position.addScaledVector(moveDir, TANK_SPEED*dt);
  }

  const ppush = collideWithObstacles(playerTank.position, 1.8);
  playerTank.position.add(ppush);
  clampArena(playerTank.position);
  playerTank.position.y = 0;
  playerTank.rotation.y = playerState.yaw + Math.PI;

  // Space to fire
  if ((keys['Space'] || keys['KeyF']) && pReload <= 0) {
    firePlayer();
  }
  if (pReload > 0) pReload -= dt;

  // ─ Reload bar
  const reloadPct = pReload <= 0 ? 100 : (1 - pReload/RELOAD_TIME)*100;
  document.getElementById('reload-fill').style.width = reloadPct+'%';

  // ─ Camera: behind & above the tank, looking at it + a bit ahead
  // fwd = direction tank faces. Camera goes OPPOSITE (behind) + up.
  const camDist = 10, camHeight = 5;
  const camPos = playerTank.position.clone()
    .addScaledVector(fwd, -camDist)          // step back behind tank
    .add(new THREE.Vector3(0, camHeight, 0)); // step up
  camera.position.lerp(camPos, 0.1);

  // Look at a point slightly in FRONT of the tank (over its hood)
  const lookAtPt = playerTank.position.clone()
    .addScaledVector(fwd, 3)
    .add(new THREE.Vector3(0, 1, 0));
  camera.lookAt(lookAtPt);

  // ─ AI
  updateAI(dt);
  // ─ Bullets
  updateBullets(dt);
  // ─ Particles
  updateParticles(dt);
  // ─ Minimap
  drawMinimap();

  renderer.render(scene, camera);
}

// ─── START ───────────────────────────────────────────────────────────────────
buildScene();
updateHUD();
loop();

document.getElementById('startBtn').addEventListener('click', ()=>{
  document.getElementById('overlay').classList.add('hidden');
  setTimeout(()=>{ document.getElementById('overlay').style.display='none'; }, 700);
  gameRunning = true;
  document.getElementById('c').requestPointerLock();
});

document.addEventListener('pointerlockchange', ()=>{
  if (!document.pointerLockElement && gameRunning) {
    // paused — click canvas to resume
  }
});

document.getElementById('c').addEventListener('click', ()=>{
  if (gameRunning) document.getElementById('c').requestPointerLock();
});
</script>
</body>
</html>
